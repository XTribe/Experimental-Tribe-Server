
exports.parseCookies = function (_cookies) {
  var cookies = {};
  
  _cookies && _cookies.split(';').forEach(function( cookie ) {
    var parts = cookie.split('=');
    cookies[ parts[ 0 ].trim() ] = ( parts[ 1 ] || '' ).trim();
  });
  
  return cookies;
}  

exports.isArray = function (ar) {
    return ar instanceof Array
           || Array.isArray(ar)
           || (!!(ar && ar !== Object.prototype) && exports.isArray(ar.__proto__));
}

/* From jQuery */
exports.isEmptyObject = function( obj ) {
  if (typeof obj == 'number' || !obj || exports.isArray(obj)) {
    return false; 
  }
  for ( var name in obj ) {
    return false;
  }
  return true;
}

exports.isDef = function(v) {
  return typeof v != 'undefined';
}

exports.isObject = function(v) {
  return typeof v == 'object' 
      && v !== null
      && !exports.isArray(v);
}

exports.isEmpty = function(v) {
  return (typeof v == 'undefined' 
              || v === null 
              || v === 0 
              || exports.isEmptyObject(v)
              || (typeof v.length != 'undefined' && v.length == 0)
         )
}

// Splits hostname:port and return the port (after checking the validity)
exports.endpointGetPort = function(ep) {
  var parts = ep.split(":");

  var port = parts[1] ? parseInt(parts[1]) : 0;

  if (port > 0 && port < 65525) {
    return port;
  }

  throw new Error("The requested TCP port is not valid");

}

// Splits hostname:port and return the hostname
exports.endpointGetHostname = function(ep) {
  var parts = ep.split(":");
  return parts[0];
}

exports.changeProcessOwnership = function(cfg) {
  if (cfg.run_as) { 
    try {
      process.setuid(cfg.run_as);
    } catch(e) {
      console.log("Cannot change uid to " + cfg.run_as + " (" + e.code + ")")
    }
  }
}


