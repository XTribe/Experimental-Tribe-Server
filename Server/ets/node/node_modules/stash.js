
var cfg = require('config').read()

exports.createClient = function(backend) {
  return new StashClient(backend);
}

var StashClient = function(backend) {
  
  this.backendName = backend || cfg.services.stash.backend
  
  if (this.backendName != 'redis' &&
      this.backendName != 'file') {
    this.backendName = 'redis';
  }

  this.backend = ('file' == this.backendName) ? new nStoreBackend() : new RedisBackend()
}

StashClient.prototype.incr = function(key, cb) {
  this.backend.incr(key, cb);
}

StashClient.prototype.set = function(key, data, expire, cb) {
  if (typeof expire == 'function') {
    cb = expire
    expire = false
  }
  this.backend.set(key, data, expire, cb);
}

StashClient.prototype.get = function(key, cb) {
  this.backend.get(key, cb);
}

StashClient.prototype.lock = function(key, cb) {
  this.backend.lock("_lock." + key, cb);
}

StashClient.prototype.unlock = function(key, cb) {
  this.backend.unlock("_lock." + key, cb);
}

StashClient.prototype.del = function(key, cb) {
  this.backend.del(key, cb);
}

StashClient.prototype.discard = function(pattern, cb) {
  this.backend.discard(pattern, cb);
}

StashClient.prototype.end = function() {
  this.backend.end();
}

var RedisBackend = function(cb) {
  this.client = require('redis').createClient(cfg.services.redis.port, cfg.services.redis.host);
  cb && cb()
}

RedisBackend.prototype.set = function(key, data, expire, cb) {
  var self = this;

  this.client.set(key, JSON.stringify(data), function(err) {
    if (err) {
      cb && cb(err);
      return;
    }
  
    if (expire) {
      self.client.expire(key, expire, function(err) {
        cb && cb(err);
      });
    } else {
      cb && cb();
    }
  });
}

RedisBackend.prototype.get = function(key, cb) {
  this.client.get(key, function(err, data) {
    cb && cb(err, JSON.parse(data));
  });
}

RedisBackend.prototype.end = function(key) {
  this.client.quit()
}

// Delete with wildcard
RedisBackend.prototype.discard = function(pattern, cb) {
  var self = this;
  this.client.keys(pattern, function(err, data) {
    for (var i=0; i < data.length; i++) {
      self.del(data[i]);
    }
    cb && cb()
  })
}

RedisBackend.prototype.del = function(key, cb) {
  this.client.del(key, function(err) {
    cb && cb(err);
  });
}

RedisBackend.prototype.incr = function(key, cb) {
  this.client.incr(key, function (err, reply) {
    cb && cb(err, reply);
  });
}

RedisBackend.prototype.lock = function(key, cb) {
  var value = Date.now() + 100;
  var self = this;
  this.client.setnx(key, value, function (err, reply) {
    if (0 == reply) {
      // FIXME: handle deadlocks
      // http://redis.io/commands/setnx
      setTimeout(function() {
    //    console.log('Retrying lock')
        self.lock(key, cb);
      }, 10);
    } else {
  //    console.log("Lock acquired")
      cb && cb(err, reply);
    }
  });
}

// FIXME: handle deadlocks
// http://redis.io/commands/setnx
RedisBackend.prototype.unlock = function(key, cb) {
  this.client.del(key, function (err) {
    cb && cb(err);
  })
}

var nStoreBackend = function(cb) {
  var self = this
  
  this.err = null
  
  this.client = require('nstore').new(cfg.services.stash.file, function(err) {
    if (err)
      throw err
  })
}

nStoreBackend.prototype.set = function(key, data, expire, cb) {

  var self = this
  
  // expire is ignored
  this.client.save(key, data, function(err) {
    cb && cb(err);
  });
  
}

nStoreBackend.prototype.lock = function(key, cb) {
  cb(null, 1);
}

nStoreBackend.prototype.unlock = function(key, cb) {
  cb();
}

nStoreBackend.prototype.get = function(key, cb) {
  if (this.err) {
    cb(err)
    return
  }
  
  var self = this

  // If we don't reload the database every time, the semi-inter-process nature
  // of EHS+MHS will make the get fail on the last key inserted (the instance)
  // This absolutely wrong from a performance POV, but we use nstore only on
  // the development server
  this.client.loadDatabase(function() { 
    self.client.get(key, function(err, data) {
      // Interpret err as a "not found" error
      if (err) {
        data = null; // null as in redis
        err = null;
      }
      cb && cb(err, data);
    })
  })
  
}

nStoreBackend.prototype.del = function(key, cb) {
  if (this.err) {
    cb(err)
    return
  }

  this.client.remove(key, function(err, data) {
    cb && cb(err, data);
  });
  
}

nStoreBackend.prototype.discard = function(pattern, cb) {

  var re = new RegExp(pattern.replace("*", ".*"))
    , client = this.client.extend(require('nstore/query')());
  
  client.all(function(err, results) {
    for (k in results) {
      if (k.match(re)) {
        client.del(k);
      }
    }
  })
  
  cb && cb();
    
}

nStoreBackend.prototype.incr = function(key, cb) {
  if (this.err) {
    cb(err)
    return
  }
  var self = this
  this.get(key, function(err, data) {
    data = data ? parseInt(data) + 1 : 1
    self.set(key, data, false, function(err) {
      cb && cb(err, data)
    });
  });
}

nStoreBackend.prototype.end = function() {
  // void
}
