

var stash = require('stash').createClient()
  , Step  = require('step')

function Instance(eId) {
  this.id       = null;
  this.eId      = eId;
  this.users    = [];
  this.complete = false;
  this.ended    = false;
  this.started  = false;
  this.created  = 0|(Date.now() / 1000);
}

exports.reset = function(cb) {
 stash.discard('open_instances:*', cb)
}

exports.createInstance = function(eId, iId, guid) {
  var i = new Instance(eId);
  // Used only for debug purposes
  if (iId) {
    i.id = iId;
  }
  // Used only for debug purposes
  if (guid) {
    i.users.push({guid: guid});
  }
  return i;
}

// Find an instance for the experiment that is not complete and put the person into it
exports.addUserToInstance = function(eId, account, nUsers, cb) {
      
  Step (
        
    function() {
      stash.lock('open_instances:' + eId, this);
    }

    ,
   
    function(err) {
      stash.get('open_instances:' + eId, this)
    }
    
    ,
    
    function(err, instances) {

      var cont = this;

      if (!instances || instances.length == 0) {
        var instance = new Instance(eId);
        stash.incr('instances', function(error, id) {
          instance.id = id;
          //log.verbose("New instance " + id + " created. Experiments has now " + self.experiment.instances.length + " instances.");
          cont(null, [instance]);
        });        
      } else {
        cont(null, instances)
      }
      
    }

    ,
    
    function(err, instances) {

      // FIFO
      var instance = instances[0]
        , users = instance.users
        , cont = this

      for (var i = 0; i < users.length; i++) {
        // The same person cannot join twice
        if (users[i].guid == account.guid) {
          throw "Cannot join twice"
        }
      }

      users.push(account);

      // Instance is complete
      if (users.length == nUsers) {
        // Remove the instance from (open) instances and flag it as complete
        instances.shift()
        instance.complete = true
      }
      
      stash.set('open_instances:' + eId, instances, function(err) {
        cont(err, instance)
      })
      
    }
    
    ,
    
    function(err, instance) {
      stash.unlock('open_instances:' + eId, function(lockErr) { // We are not interested on this error
        cb(err, instance)
      });
    }
  
  );
  
}

exports.removeUserFromInstance = function(instance, guid, cb) {
  
  for (var i=0; i < instance.users.length; i++) {
    if (instance.users[i].guid == guid) {
      instance.users.splice(i,1);
      break;
    }
  }

  // If the instance is complete, it only lives in memory and not in open_instances
  // This method is therefore called only when users are leaving a complete
  // instance (and e can safely update the users[] in instance
  if (instance.complete) {
    cb(null, instance.users);
  } else {
  // The instance is not complete, so it leaves in Redis and must be locked
    
    Step (
          
      function() {
        stash.lock('open_instances:' + instance.eId, this);
      }
  
      ,
     
      function(err) {
        stash.get('open_instances:' + instance.eId, this)
      }
      
      ,
      
      function(err, instances) {

        var cont = this
        
        for (var i=0; i < instances.length; i++) {
          if (instances[i].id == instance.id) {
            instances[i].users = instance.users
            break;
          }
        }
        
        // If there are no more users in the instance, remove it
        // This will happen only for open instances
        if (instances[i].users.length == 0) {
//          console.log("Open instance removed because without users")
          instances.splice(i,1);
        }
        
        stash.set('open_instances:' + instance.eId, instances, this)
        
      }
      
      ,

      function(err) {
        stash.unlock('open_instances:' + instance.eId, function(err) {
          cb(err, instance.users)
        });
      }
      
    )
    
  }
  
}

exports.save = function(instance, cb) {

  stash.set('instance_' + instance.id, instance, cb)
  
  /*
  {
      id:    instance.id
    , eId:   instance.eId
    , created: instance.created
    , ended: false
    , users: instanceData.users.map(function(u) { return { 'guid': u.guid, 'uId': u.uId } } )
  }, function() {
  })
  */
}

exports.remove = function(id, cb) {
  stash.del('instance_' + id, cb);
}
