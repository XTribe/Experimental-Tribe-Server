

var stash = require('stash').createClient()
  , Step  = require('step')
  , Pubsub  = require('pubsub');

function Instance(eId) {
  this.id       = null;
  this.eId      = eId;
  this.users    = [];
  this.complete = false;
  this.ended    = false;
  this.started  = false;
  this.created  = 0|(Date.now() / 1000);
}

exports.reset = function(cb) {
 stash.discard('open_instances:*', cb)
}

exports.closeHungedInstances = function(pub,site) {
  pub.publish(Pubsub.channels.INSTANCE_HUNGED, {
      site: site
  });
}

exports.createInstance = function(eId, iId, guid) {
  var i = new Instance(eId);
  // Used only for debug purposes
  if (iId) {
    i.id = iId;
  }
  // Used only for debug purposes
  if (guid) {
    i.users.push({guid: guid});
  }
  return i;
}

// Find an instance for the experiment that is not complete and put the person into it
exports.addUserToInstance = function(eId, account, nUsers, share_languages,cb) {
      
  Step (
        
    function() {
      stash.lock('open_instances:' + eId, this);
    }

    ,
   
    function(err) {
      stash.get('open_instances:' + eId, this)
    }
    
    ,
    
    function(err, instances) {

      var cont = this;

      if (!instances || instances.length == 0) {
        var instance = new Instance(eId);
        stash.incr('instances', function(error, id) {
          instance.id = id;
          //log.verbose("New instance " + id + " created. Experiments has now " + self.experiment.instances.length + " instances.");
          cont(null, [instance], id+1);
        });     
      } else {
        stash.get('instances', function(error, id) {
          cont(null, instances, id+1);
        }); 

        //cont(null, instances,id)
      }
      
    }

    ,
    
    function(err, instances, id_next_instance) {
      // FIFO
      var instance = instances[0]
        , users = instance.users
        , cont = this
        , instance_language = ''

      for (var i = 0; i < users.length; i++) {
        
        // The same person cannot join twice
        if (users[i].guid == account.guid) {
          throw "Cannot join twice"
        }
      }

      console.log("ACCOUNT uId: "+JSON.stringify(account.uId)+ " guid: "+JSON.stringify(account.guid));
      console.log("INSTANCES: "+instancesFriendlyPrint(instances));

      // ------ CALCULATE COMMON LANGUAGE BETWEEN USER and EXPERIMENT (in order to join people having common languages)
      // share_languages could be
      // - an array like {"available_language":["Afar","English","Italian"],"not_available_language":[]}
      // - empty array if share_language option has been checked but no spoken language has been chosen 
      // - 0 if share_languages option has not been checked

      var common_languages_user_exp = [];
      var user_spoken_languages=[];
      if(share_languages!='0'){
        console.log("--- Share language Checked "+JSON.stringify(share_languages));
        // getting current user languages available
        if (account.data.spoken_languages!=null) {
          for (var i = 0; i < account.data.spoken_languages.length; i++) {
            user_spoken_languages[i]=account.data.spoken_languages[i];
           }
        }
        console.log("USER LANGUAGES: "+JSON.stringify(user_spoken_languages)+" USER "+account.guid);

        /* Not available languages are sent, but, since user speaking not available language are not allowed to join and
         to arrive here, it not really makes sense to save this information, wasting computational time. I leave code 
         commented to resume it during future implementations. */
        var exp_available_languages=[];
        //var exp_not_available_languages=[];
        if (share_languages['available_language'].length==0) {
          // Share language Checked but NO languages defined for the experiment
          console.log("--- Share language Checked but NO languages defined for the experiment ");
        }else{
          // Share language Checked AND languages defined for the experiment
          console.log("--- Share language Checked AND languages defined for the experiment ");          
        }

        exp_available_languages=share_languages['available_language'];
        //exp_not_available_languages=share_languages['not_available_language'];
        console.log("EXPERIMENT LANGUAGES: "+JSON.stringify(exp_available_languages)+" USER "+account.guid);
        //console.log("EXPERIMENT LANGUAGES NOT: "+JSON.stringify(exp_not_available_languages)+" USER "+account.guid);

        // Ideally, here we had to subtract not available languages, but user speaking not available languages are
        // not allowed to join, so it will never happen that a user with a proibithed language gets here
        common_languages_user_exp = intersect_safe(exp_available_languages,user_spoken_languages, 1);

        // if there are setted languages for the experiment and no language setted by the user he should pass
        // for we can't say what language he speaks
        console.log("COMMON LANGUAGES USER-EXP: "+JSON.stringify(common_languages_user_exp));
        // ------ END ---- CALCULATE COMMON LANGUAGE BETWEEN USER and EXPERIMENT

        // ------ CALCULATE COMMON LANGUAGE BETWEEN USER and INSTANCES (nothing = "can't say" so you can go on like you have "all")
        // At this point, common_languages_user_exp contains common languages between experiment and actual user
        // If user_spoken_languages and exp_available_languages are filled, contains the common language between the two, maybe nothing
        // If user_spoken_languages is filled and exp_available_languages is NOT filled, contains user_spoken_languages
        // If user_spoken_languages is NOT filled and exp_available_languages is filled, contains nothing 

        var common_languages_exp_instance;
        var instance_found = -1;
        var common_languages_single_instance;
        var users_tmp=[];
        // for every available and open instance
        for (var j = 0; j < instances.length; j++) {
          var all_users_languages_empty=1;
          // pick users from the selected instance
          users_tmp = instances[j].users;
          if (user_spoken_languages.length!=0) { all_users_languages_empty=0; };
          // begin with language spoken by the incoming user and compare with others in the current instance
          common_languages_single_instance = user_spoken_languages;

          console.log("....ANALYZING INSTANCE #"+j+"-"+instances[j].id+" USERS "+instancesFriendlyPrint(instances[j]));
          if (users_tmp.length !=0) {
            // for every user create an array of languages spoken and find common
            for (var i = 0; i < users_tmp.length; i++) {
              // otherwise maybe same person would be put in instance twice
              if(users_tmp[i].guid!=account.guid){ 
                var user_i_spoken_languages=[];
                if (users_tmp[i].data.spoken_languages!=null) {
                  for (var m = 0; m < users_tmp[i].data.spoken_languages.length; m++) {
                    user_i_spoken_languages[m]=users_tmp[i].data.spoken_languages[m];
                  }
                  all_users_languages_empty=0;
                }
                console.log("USER uId: "+JSON.stringify(users_tmp[i].uId)+ " guid: "+JSON.stringify(users_tmp[i].guid)+" LANGUAGES "+JSON.stringify(user_i_spoken_languages));
                // common languages between user and experiment and other user in the istance
                if (user_i_spoken_languages!=null) {
                  common_languages_single_instance = intersect_safe(common_languages_single_instance,user_i_spoken_languages, 1);
                }
              }
            }
            console.log("SINGLE INSTANCE USERS COMMON LANGUAGES FOUND: "+JSON.stringify(common_languages_single_instance));
            
            // common language between experiment and single instance
            common_languages_exp_instance = intersect_safe(common_languages_single_instance,common_languages_user_exp, 0);

            console.log("RESULTS: common_languages_exp_instance: "+JSON.stringify(common_languages_exp_instance)+
              " exp_available_languages: "+JSON.stringify(exp_available_languages)+
              " common_languages_single_instance: "+JSON.stringify(common_languages_single_instance)+
              " all_users_languages_empty: "+JSON.stringify(all_users_languages_empty));
            
            // if there are common languages between experiment and users of this instance (and incoming user)
            // OR there are common languages between users of instance (and incoming user) and no language defined for the experiment
            // OR there are no common languages between users of instance (and incoming user) but cause no one have languages setted
            if (common_languages_exp_instance.length!=0 
                || (exp_available_languages.length==0 && common_languages_single_instance.length!=0)
                || all_users_languages_empty ) {
              instance_found = j;
              break;
            }
          }// Otherwise, I'm the first in this instance!          
        }
        // ------ END ----- CALCULATE COMMON LANGUAGE BETWEEN USER and EXPERIMENT

        // This happens only if there are other people in the instance and an instance valid has been found
        // otherwise it proceed with the newly created instance
        if (instance_found!=-1) {
          console.log("ISTANZA STESSA LINGUA TROVATA x lingua "+ common_languages_single_instance + " istanza "+instance_found);
          instance = instances[instance_found];
          users = instance.users;
        };

        // if there are istances but no one valid opens a new one (if the fifo current is empty of user use that, so go on )
        if (instance_found==-1 && instances[0].users.length!=0) {          
            instance = new Instance(eId);
            users = instance.users;
            instance.id=id_next_instance;
            instances.push(instance)
            stash.incr('instances', function(error, id) {
              instance.id = id;
            });
            console.log("+++Created new instance "+instance.id+"*****INSTANCE: "+instancesFriendlyPrint(instance)+" INSIDE *****INSTANCES: "+instancesFriendlyPrint(instances));
        }
      }else{
        console.log("--- Share language NOT checked "+JSON.stringify(share_languages));
      }
      
      // add user to selected instance
      users.push(account);
     
      // Instance is complete
      if (users.length == nUsers) {
        // Remove the instance from (open) instances and flag it as complete
        console.log("---Removed open instance "+instance.id+" from "+instancesFriendlyPrint(instances));
        removeFirstElementInArrayWithKeyEqualTo(instances,'id',instance.id);
        // NB: was instances.shift()
        instance.complete = true
      }
      
      console.log("+++INSTANCES in open instances "+instancesFriendlyPrint(instances));
      stash.set('open_instances:' + eId, instances, function(err) {
        cont(err, instance)
      })

    }
    
    ,
    
    function(err, instance) {
      stash.unlock('open_instances:' + eId, function(lockErr) { // We are not interested on this error
        cb(err, instance)
      });
    }
  
  );
  
}

exports.removeUserFromInstance = function(instance, guid, cb) {
  
  for (var i=0; i < instance.users.length; i++) {
    if (instance.users[i].guid == guid) {
      instance.users.splice(i,1);
      break;
    }
  }

  // If the instance is complete, it only lives in memory and not in open_instances
  // This method is therefore called only when users are leaving a complete
  // instance (and e can safely update the users[] in instance
  if (instance.complete) {
    cb(null, instance.users);
  } else {
  // The instance is not complete, so it leaves in Redis and must be locked
    
    Step (
          
      function() {
        stash.lock('open_instances:' + instance.eId, this);
      }
  
      ,
     
      function(err) {
        stash.get('open_instances:' + instance.eId, this)
      }
      
      ,
      
      function(err, instances) {

        console.log("#### INSTANCES in open_instance called by "+instance.id+" BEFORE: "+instancesFriendlyPrint(instances));
        var cont = this;
        for (var i=0; i < instances.length; i++) {
          if (instances[i].id == instance.id) {
            instances[i].users = instance.users;
            
            // If there are no more users in the instance, remove it
            // This will happen only for open instances
            if (instances[i].users.length == 0) {
              //console.log("Open instance removed because without users")
              instances.splice(i,1);
            }
            break;
          }
        }

        console.log("#### INSTANCES in open instances called by "+instance.id+" AFTER: "+instancesFriendlyPrint(instances));
        stash.set('open_instances:' + instance.eId, instances, this)
        
      }
      
      ,

      function(err) {
        stash.unlock('open_instances:' + instance.eId, function(err) {
          cb(err, instance.users)
        });
      }
      
    )
    
  }
  
}

exports.save = function(instance, cb) {

  stash.set('instance_' + instance.id, instance, cb)
  
  /*
  {
      id:    instance.id
    , eId:   instance.eId
    , created: instance.created
    , ended: false
    , users: instanceData.users.map(function(u) { return { 'guid': u.guid, 'uId': u.uId } } )
  }, function() {
  })
  */
}

exports.remove = function(id, cb) {
  stash.del('instance_' + id, cb);
}

// Calculate intersection between two array leaving them untouched
// if count_empty_as_full, the intersection of a filled array with an empty array returns the filled
function intersect_safe(a, b, count_empty_as_full){
  var ai=0, bi=0;
  var result = new Array();

  // sorting arrays is necessary to the algorithm to work. The arrays gets duplicated
  // to make sure to leave untouched the original array
  // EDIT: assume array arrives already sorted to optimize
  // In order to restore sorting: intersect_safe(c, d)
  // var a=c.slice().sort();
  // var b=d.slice().sort();

  // if one is empty return the other
  if (count_empty_as_full) {
    //console.log("a: "+JSON.stringify(a)+"b: "+JSON.stringify(b));
    if (a.length==0) { return b;  };
    if (b.length==0) { return a;  };
  };
  
  while( ai < a.length && bi < b.length )
  {
     if      (a[ai] < b[bi] ){ ai++; }
     else if (a[ai] > b[bi] ){ bi++; }
     else /* they're equal */
     {
       result.push(a[ai]);
       ai++;
       bi++;
     }
  }
  return result;
}

function removeFirstElementInArrayWithKeyEqualTo(array,key,value){
  var itemRemoved=false;
  //console.log("array BEF: "+JSON.stringify(array)+" key: "+JSON.stringify(key)+"value: "+JSON.stringify(value));
  
  var removeIndex='';
  for (var i in array) {
   //console.log("i: "+JSON.stringify(i)+"array["+i+"]: "+JSON.stringify(array[i])+"array["+i+"][key]: "+JSON.stringify(array[i][key]));
   if(array[i][key] == value){
     removeIndex=i;
     break;
     itemRemoved=true;
   }
  }
  if (removeIndex!='') {
    array.splice(removeIndex,1);
    //console.log("Remove item at index "+removeIndex);
  };
  //console.log("array AFT: "+JSON.stringify(array));
  return itemRemoved;
}

// Useful for debug, print instances array without unuseful data
function instancesFriendlyPrint(instances){
  var instancesFriendlyPrint="";
  if (instances.length!=0) {
    for (var j = 0, len = instances.length; j < len; j++) {
      instancesFriendlyPrint+=" | ins: "+JSON.stringify(instances[j].id)+" usr: | ";
      if (typeof instances[j].users != 'undefined' ){
        if (instances[j].users.length!=0){
          for (var i = 0, lenU = instances[j].users.length; i < lenU; i++) {
            instancesFriendlyPrint+=" uId "+JSON.stringify(instances[j].users[i].uId)+" guId "+JSON.stringify(instances[j].users[i].guid) + " | ";
          }
        }
      }
      instancesFriendlyPrint=instancesFriendlyPrint+ " | ";
    }
  };
  return JSON.stringify(instancesFriendlyPrint);
}
